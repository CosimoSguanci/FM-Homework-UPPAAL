<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Grid Dimension Declaration
const int N = 10;
const int M = 10;
clock g;
// Max task
const int MAX_TASK = 25;

/************************************/
/*     Custom types declaration     */
/************************************/

typedef struct {
    int[-1, N] row;
    int[-1, M] col;
} position;

typedef struct {
    position pos;
    bool taken;
} pod;

/*************************************/
/*       Functions declaration       */
/*************************************/

position createPosition(int row, int col) {
    position pos;
    pos.row = row;
    pos.col = col;
    return pos;
}

/*************************************/
/*       Constants declaration       */
/*************************************/

// Number of Pods
const int NUM_OF_PODS = 30;

// Entry and delivery points
const position entryPoint     = createPosition(9, 9);
const position deliveryPoint  = createPosition(0, 9);
const position nullPosition   = createPosition(-1, -1);

// Number of robots
const int NUM_OF_ROBOTS = 3;

// Possible states of each cell on the grid
const int EMPTY     = 0;
const int ROBOT     = 1;
const int POD       = 2;
const int POD_ROBOT = 3; // pod + robot in the same cell

// Grid composition
int[0,3] grid[N][M] = {
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY}
};

// Initialization of Pods and their positions
pod pods[NUM_OF_PODS] = {
    {{1, 0}, false}, {{1, 1}, false}, {{1, 2}, false}, {{1, 3}, false},
    {{1, 4}, false}, {{1, 5}, false}, {{3, 0}, false}, {{3, 1}, false},
    {{3, 2}, false}, {{3, 3}, false}, {{3, 4}, false}, {{3, 5}, false},
    {{5, 0}, false}, {{5, 1}, false}, {{5, 2}, false}, {{5, 3}, false},
    {{5, 4}, false}, {{5, 5}, false}, {{7, 0}, false}, {{7, 1}, false},
    {{7, 2}, false}, {{7, 3}, false}, {{7, 4}, false}, {{7, 5}, false},
    {{9, 0}, false}, {{9, 1}, false}, {{9, 2}, false}, {{9, 3}, false},
    {{9, 4}, false}, {{9, 5}, false}
};


/********************************************/
/*       Shared variables declaration       */
/********************************************/

// set by taskManager, read by the robots when the broadcast channel is activate
// every robot will read to his position and if the position is different from {-1,-1}
// the robot will be able to move to that pod
position robotTask[NUM_OF_ROBOTS] = {
    nullPosition,
    nullPosition,
    nullPosition
}; 

int synchronizationRequest;  // used by TaskManager

int[-1, NUM_OF_ROBOTS] nextPositionRobotId;     // used by Semaphore
int[-1, NUM_OF_ROBOTS] justMovedRobotId;        // used by Semaphore

position nextPositionShared = nullPosition;

/*************************************/
/*       Channels declaration        */
/*************************************/

broadcast chan canMove, cannotMove;
broadcast chan releaseTask, noFeasibleMoves, claim, tryingToMove, justMoved, go, takeItem;</declaration>
	<template>
		<name>Semaphore</name>
		<declaration>// The next positions in which robots will go ASAP. They are set
// when a robot is allowed to go to a cell, and they are reset to {-1, -1}
// when the robot has performed the move
position nextPositions[NUM_OF_ROBOTS] = {
    nullPosition,
    nullPosition,
    nullPosition
};

// A function to check if the given position is already scheduled to be
// occupied by another robot, that has not performed the move yet
bool isAlreadyOccupiedForNextPositions(int row, int col) {
    int i = 0;
    for(i = 0; i &lt; NUM_OF_ROBOTS; i++) {
        if(nextPositions[i].row == row &amp;&amp; nextPositions[i].col == col) {
            return true;
        }
    }

    return false;
}


void setNextPositions(int row, int col, int robotId) {
    nextPositions[robotId].row = row;
    nextPositions[robotId].col = col;
}

bool isEmptyOrPod(position pos) {
    bool empty, pod;

    if(pos.row&gt;=0 &amp;&amp; pos.row&lt;N &amp;&amp; pos.col&gt;=0 &amp;&amp; pos.col&lt;M){
        empty = grid[nextPositionShared.row][nextPositionShared.col] == EMPTY;
        pod = grid[nextPositionShared.row][nextPositionShared.col] == POD;
        return empty || pod;
    } else { return false; }
    
        
}</declaration>
		<location id="id0" x="-136" y="-110">
			<name x="-146" y="-144">CannotMoveInThisCell</name>
		</location>
		<location id="id1" x="102" y="68">
			<name x="0" y="59">initial_state</name>
		</location>
		<location id="id2" x="-17" y="195">
			<name x="-25" y="212">SomeoneTryingToMove</name>
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="153" y="25">justMoved?</label>
			<label kind="assignment" x="153" y="42">nextPositions[justMovedRobotId] = nullPosition</label>
			<nail x="119" y="25"/>
			<nail x="153" y="34"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="552" y="-144">noFeasibleMoves?</label>
			<nail x="204" y="-110"/>
			<nail x="773" y="-110"/>
			<nail x="773" y="68"/>
			<nail x="586" y="68"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-136" y="195">tryingToMove?</label>
			<nail x="-136" y="195"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="-93" y="-59">!isEmptyOrPod(nextPositionShared) || 
isAlreadyOccupiedForNextPositions(nextPositionShared.row, nextPositionShared.col)</label>
			<label kind="synchronisation" x="-93" y="-25">cannotMove!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="161" y="102">isEmptyOrPod(nextPositionShared) &amp;&amp; 
!isAlreadyOccupiedForNextPositions(nextPositionShared.row, nextPositionShared.col)</label>
			<label kind="synchronisation" x="161" y="136">canMove!</label>
			<label kind="assignment" x="161" y="152">setNextPositions(nextPositionShared.row, nextPositionShared.col, nextPositionRobotId)</label>
			<nail x="170" y="195"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="8" y="127">tryingToMove?</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>int mean, int stdDev</parameter>
		<declaration>clock t;

int delay;

void computeDelay() {
    delay = fint(random_normal(mean, stdDev));
}</declaration>
		<location id="id3" x="-229" y="-85">
			<name x="-272" y="-102">Idle</name>
		</location>
		<location id="id4" x="-42" y="-85">
			<name x="-52" y="-119">Taking_item</name>
			<label kind="invariant" x="-52" y="-68">t &lt;= delay</label>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-153" y="-17">t &gt;= delay</label>
			<label kind="synchronisation" x="-144" y="0">go!</label>
			<nail x="-136" y="-25"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-170" y="-187">takeItem?</label>
			<label kind="assignment" x="-153" y="-170">t = 0, computeDelay()</label>
			<nail x="-136" y="-144"/>
		</transition>
	</template>
	<template>
		<name>Robot</name>
		<parameter>int id, int K, int lambda</parameter>
		<declaration>clock t;

// Notable positions that the robot must remember
position currentPosition = nullPosition;
position currentPodPosition;
position nextPosition;

// True if the pathfinder cannot find a move that is acceptable by the Semaphore
bool noPossibleMoves;

// What is the robot goal in this phase
int[0, 2] target;

// Possible target states
const int TO_DELIVERY = 0; // If the robot has taken the pod and has to carry it to the Human
const int TO_POD      = 1; // If a task was given to the robot, and it has to go to pick up the pod
const int BACK_TO_POD = 2; // If the task was fullfilled but the pod has to return to its initial position

// Next goal position for the robot
position goal;

// Path to follow
meta position path[N*M];

// This function actually performs the move actions by changing the grid
void updateGridAfterMove() {

    if(grid[currentPosition.row][currentPosition.col] == ROBOT) {
       grid[currentPosition.row][currentPosition.col] = EMPTY;
    }
    else if(grid[currentPosition.row][currentPosition.col] == POD_ROBOT) { // a cell is POD_ROBOT only when a pod has just been released
        grid[currentPosition.row][currentPosition.col] = POD;
    }

    if(grid[nextPosition.row][nextPosition.col] == POD) {
        grid[nextPosition.row][nextPosition.col] = POD_ROBOT;
    }
    else {
        grid[nextPosition.row][nextPosition.col] = ROBOT;    
    }
    
    currentPosition = nextPosition;
}

// True if the robot has to move to another cell to reach its target
bool isNormalMove() {
    return 
        !(target == TO_DELIVERY &amp;&amp; currentPosition == deliveryPoint) &amp;&amp;
        !(target == TO_POD &amp;&amp; currentPosition == currentPodPosition) &amp;&amp;
        !(target == BACK_TO_POD &amp;&amp; currentPosition == currentPodPosition);
}

// Sets the pod as NOT TAKEN, called when the pod is returned back to its initial position
void releasePod() {
    int i;
    for(i = 0; i &lt; NUM_OF_PODS; i++) {
        if(pods[i].pos.row == currentPodPosition.row &amp;&amp; pods[i].pos.col == currentPodPosition.col) {
            pods[i].taken = false;
            grid[currentPodPosition.row][currentPodPosition.col] = POD_ROBOT;
            currentPodPosition = nullPosition;
            return;
        }
    }
}

// Called when the robot is picking up a pod
void takePod() { grid[currentPodPosition.row][currentPodPosition.col] = ROBOT; }

// Used when robot change target to update it's variables
void updateTarget(int[0,2] update){
    // Simply update the tager variable
    target = update;
    
    // Depending on target, update other wariables
    if(update == TO_DELIVERY){
        goal = deliveryPoint;
    } else if(update == TO_POD){
        currentPodPosition = robotTask[id];
        goal = currentPodPosition;
    } else if(update == BACK_TO_POD){
        goal = currentPodPosition;
    }
}

// Return the next position in the path to the goal
position getNextMove(){ return path[0]; }

// Move already performed, so remove path[0] and shift up every position
void advancePath(){
    int i, max = N*M-1;
    // Shifting everything up
    for(i=0; i&lt;max; i++){ path[i] = path[i+1]; }
}


/********************************************/
/*       Path Finding Support Functions     */
/********************************************/

// Pathfinding helper variables
const position UP     = createPosition(-1, 0);
const position RIGHT  = createPosition(0, 1);
const position DOWN   = createPosition(1, 0);
const position LEFT   = createPosition(0, -1);
const position NULL   = nullPosition;

// Add two positions
position addPos(position a, position b){ return createPosition(a.row + b.row, a.col + b.col); }
// Copy a position
position copy(position p){position ret = {p.row, p.col}; return ret;}
// Return true if 2 positions are equal
bool isEqual(position a, position b){ return a.row==b.row &amp;&amp; a.col==b.col; }
// Reset to NULL position all path positions
void resetPath(){ int i; for(i=0; i&lt;N*M; i++){ path[i] = nullPosition; } }

// Return true if a position is a "possible" position
bool isFeasible(position p, bool reroute){
    bool base = false;
    bool pod = false;
    bool next = false;

    // Standard feasibility check
    base = p.row&gt;=0 &amp;&amp; p.row&lt;N &amp;&amp; p.col&gt;=0 &amp;&amp; p.col&lt;M;
    
    // Only if on the grid, check other things
    if(base){
        // If robot is moving a pod, check if pos has a pod
        if(target==BACK_TO_POD || target==TO_DELIVERY){ pod = not(grid[p.row][p.col] == POD || grid[p.row][p.col] == POD_ROBOT); }
        //Otherwise, make this useless
        else { pod = true; }
        
        // If this is after a cannotMove, check if it's equal to already excluded nextMove
        if(reroute){ next = not(p.row==nextPosition.row &amp;&amp; p.col==nextPosition.col); }
        else { next = true; }
        
        return pod &amp;&amp; next;
    } else { return false; }

}

// Romve the last position in the queue
position remove(position&amp; queue[N*M], int&amp; len){
    // Obtain correct pos
    position pos = queue[len-1];
    
    // Move up one position every other 
    queue[len-1] = nullPosition;
    
    // Update actual array length
    len = len - 1;

    return pos;
}

// Add position to the queue
void add(position pos, position&amp; queue[N*M], int&amp; len){
    // Do something only if enough space
    if(len &lt; N*M){
        // Insert new pos
        queue[len] = pos;

        // Increase length array
        len = len + 1;
    }
    
}

// Get the next direction clockwise
position getNextDir(position d){
    if(isEqual(d, UP))           { return copy(RIGHT); }
    else if(isEqual(d, RIGHT))   { return copy(DOWN); }
    else if(isEqual(d, DOWN))    { return copy(LEFT); }
    else                         { return copy(UP); }
}

// Get the previous direction clockwise
position getPrevDir(position d){
    if(isEqual(d, UP))           { return copy(LEFT); }
    else if(isEqual(d, LEFT))    { return copy(DOWN); }
    else if(isEqual(d, DOWN))    { return copy(RIGHT); }
    else                         { return copy(UP); }
}

// To eliminate very stupid paths, we decide the first direction to check in a greedy way
position greedyStartDir(position p){
    // Vector representing distance on x axis
    int x = goal.col - p.col;
    // Vector representing distance on y axis
    int y = goal.row - p.row;
    
    // If abs(x) &gt;= abs(y) then the first direction to check should be RIGHT
    if(abs(x) &gt;= abs(y)){
        if (x&gt;=0)   { return getPrevDir(RIGHT); }
        else        { return getPrevDir(LEFT); }
    } else {
        if (y&gt;=0)   { return getPrevDir(UP); }
        else        { return getPrevDir(DOWN); }
    }
}



/************************************************/
/*     Path finding Algorithm (Backtracking)    */
/************************************************/

void findPath(bool reroute){
    // Queue needed to seach the entire matrix
    position queue[N*M];
    // Current queue length
    int len = 0;
    // Matrix representing if a cell is already visited
    bool visited[N][M];
    // Control variables for while loop
    bool searching = true;
    bool found = false;
    bool added = false;
    // Miscellaneous
    int i, j;
    position dir, next, curPos;
    
    // Initialize visited matrix
    for(i=0; i&lt;N; i++){ for(j=0; j&lt;M; j++){ visited[i][j] = false; } }
    // Reset path
    resetPath();

    // Given that it was outside of the grid, set the robot on entryPoint
    if(currentPosition == nullPosition) { curPos = entryPoint; }
    // Else initialize curPos normally
    else { curPos = currentPosition; }
    
    // Add first position that in the end will be removed
    add(curPos, queue, len);
    if(not isEqual(curPos, NULL)) { visited[curPos.row][curPos.col] = true; }
    
    while(searching &amp;&amp; not found){
        if(len &gt; 0){
            // Goal found, ending everything :)
            if(isEqual(queue[len-1], goal)){ found = true; }
            else {
                // Set to visited the cell
                visited[queue[len-1].row][queue[len-1].col] = true;
            
                // Let's start from one direction
                dir = greedyStartDir(queue[len-1]);
                // Check each direction
                for(i=0; i&lt;4; i++){
                    // Obtain next direction to check
                    dir = getNextDir(dir);
                    // Obtain the resulting position after "moving" in the specified direction
                    next = addPos(queue[len-1], dir);
                    // Only is feasible and not already visited, add the position to the queue
                    if(isFeasible(next, reroute)){ 
                        if(not visited[next.row][next.col]){
                            add(next, queue, len);
                            added = true;
                            i=4; // Needed to end the direction loop
                        }
                    }
                }
                // If no position was added, then the current position is not part of the solution, so it's removed from queue
                if(not added){ remove(queue, len); }
                // Variable reset to be ready for next cycle
                added = false;
            }

        } else { searching = false; }
    }

    if(found){
        // Copy the queue from element 1 (0 element is useless as it is the current position)
        for(i=1; i&lt;len; i++){ path[i - 1] = queue[i]; }
    } else { noPossibleMoves = true; }
}

void updateGridIfFirstMove() {
    if(currentPosition == nullPosition) {
        currentPosition = entryPoint;
        grid[currentPosition.row][currentPosition.col] = ROBOT;
    }
}

</declaration>
		<location id="id5" x="892" y="450">
			<name x="909" y="442">Moving</name>
			<label kind="invariant" x="909" y="459">t &lt;= K</label>
		</location>
		<location id="id6" x="280" y="459">
			<name x="246" y="485">DecideAction</name>
			<committed/>
		</location>
		<location id="id7" x="892" y="-68">
			<name x="882" y="-102">WaitingGreenLight</name>
			<committed/>
		</location>
		<location id="id8" x="297" y="-68">
			<name x="238" y="-110">DecideDirection</name>
			<committed/>
		</location>
		<location id="id9" x="-51" y="170">
			<name x="-178" y="161">WaitingHuman</name>
		</location>
		<location id="id10" x="-144" y="0">
			<name x="-195" y="17">ClaimingTask</name>
		</location>
		<location id="id11" x="-399" y="0">
			<name x="-450" y="-25">idle</name>
			<label kind="exponentialrate" x="-467" y="-8">lambda</label>
		</location>
		<location id="id12" x="-42" y="-68">
			<name x="-143" y="-102">TaskChecking</name>
			<committed/>
		</location>
		<location id="id13" x="357" y="-314">
			<name x="331" y="-348">WaitingForPossibleMoves</name>
			<label kind="invariant" x="382" y="-323">t &lt;= K</label>
		</location>
		<location id="id14" x="-306" y="-161">
			<name x="-332" y="-195">WaitingTask</name>
			<label kind="invariant" x="-323" y="-144">t &lt;= K</label>
		</location>
		<init ref="id11"/>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="280" y="161">currentPosition == goal</label>
			<nail x="425" y="153"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id11"/>
			<label kind="guard" x="-442" y="-178">t &gt;= K</label>
			<nail x="-399" y="-161"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id14"/>
			<label kind="guard" x="-212" y="-187">robotTask[id] == nullPosition</label>
			<label kind="assignment" x="-204" y="-204">t = 0</label>
			<nail x="-42" y="-161"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="552" y="102">target == TO_POD &amp;&amp;
currentPosition == currentPodPosition</label>
			<label kind="assignment" x="552" y="136">takePod(),
updateTarget(TO_DELIVERY),
findPath(false)</label>
			<nail x="544" y="408"/>
			<nail x="552" y="59"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id11"/>
			<label kind="guard" x="-221" y="459">target == BACK_TO_POD &amp;&amp;
currentPosition == currentPodPosition</label>
			<label kind="assignment" x="-221" y="493">releasePod(),
resetPath()</label>
			<nail x="-399" y="450"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id8"/>
			<label kind="guard" x="212" y="-340">t &gt;= K</label>
			<label kind="assignment" x="187" y="-306">noPossibleMoves = false</label>
			<nail x="170" y="-314"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id13"/>
			<label kind="guard" x="348" y="-263">noPossibleMoves</label>
			<label kind="synchronisation" x="348" y="-246">noFeasibleMoves!</label>
			<label kind="assignment" x="348" y="-229">t = 0</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id8"/>
			<label kind="guard" x="17" y="-144">robotTask[id] != nullPosition</label>
			<label kind="assignment" x="17" y="-127">updateTarget(TO_POD),
updateGridIfFirstMove(),
findPath(false)</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="629" y="416">t &gt;= K</label>
			<label kind="synchronisation" x="629" y="433">justMoved!</label>
			<label kind="assignment" x="629" y="450">updateGridAfterMove(),
justMovedRobotId = id,
advancePath()</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="901" y="136">canMove?</label>
			<label kind="assignment" x="901" y="153">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="552" y="-229">cannotMove?</label>
			<label kind="assignment" x="552" y="-212">findPath(true)</label>
			<nail x="595" y="-187"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="484" y="-51">!noPossibleMoves &amp;&amp; currentPosition != goal</label>
			<label kind="synchronisation" x="484" y="-34">tryingToMove!</label>
			<label kind="assignment" x="484" y="-102">nextPosition = getNextMove(),
nextPositionRobotId = id,
nextPositionShared = nextPosition</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="68" y="263">isNormalMove()</label>
			<nail x="127" y="289"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="-255" y="246">currentPosition == deliveryPoint &amp;&amp; 
target == TO_DELIVERY</label>
			<label kind="synchronisation" x="-178" y="289">takeItem!</label>
			<nail x="-51" y="382"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="17" y="42">go?</label>
			<label kind="assignment" x="-43" y="76">updateTarget(BACK_TO_POD),
findPath(false)</label>
			<nail x="-51" y="76"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-34" y="-34">releaseTask?</label>
			<nail x="-42" y="0"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-297" y="-51">claim!</label>
			<label kind="assignment" x="-365" y="-34">synchronizationRequest = id</label>
		</transition>
	</template>
	<template>
		<name>TaskManager</name>
		<parameter>int mean, int stdDev</parameter>
		<declaration>clock t;

int delay;

void computeDelay() {
    delay = fint(random_normal(mean, stdDev));
}


//this is a queue which works with a FIFO policy, where MAX_T is the maximum number of tasks settable
position tasks[MAX_TASK];
//to keep track of the actual number of task present in the tasks array
int[0, MAX_TASK] actualLength;
//here there is the id of the robot which has claimed a task
int[-1,NUM_OF_ROBOTS] actualRobotId;
//used to signal if the max capacity of the array is reached
bool exploded;
//used to signal if all pods in the grid is tasked
bool allPodsUsed;

//to initialize every local variable
void settingUp() {
    int j;
    for (j = 0; j &lt; MAX_TASK; j++) {
        tasks[j] = createPosition(-1,-1);
    }
    actualLength = 0;
    actualRobotId = -1;
    exploded = false;
    allPodsUsed = false;
}

//This checks the position of the pod to understand if it is the same of the pod in position i inside the tasks queue
bool checkIdentity(pod myPod, int i) {
    if (myPod.pos.row == tasks[i].row) {
        if (myPod.pos.col == tasks[i].col) {
            return true;
        }
    }
    return false;
}

//This verify if the pod in input is present in the queue checking all the tasks array (if it is the case)
bool thisPodPositionIsPresentInTasks(pod myPod) {
    int i;
    for (i = 0; i &lt; actualLength; i++) {
        if (checkIdentity(myPod, i)) {
            return true;
        }
    }
    return false;
}

//find another "random" number adding 1 to the previous random number, keeping attention to the NUM_OF_PODS present in the layout
int anotherTmp(int tmp) {
    int myTmp = tmp;
    if (tmp == NUM_OF_PODS - 1)
        myTmp = 0;
    else
        myTmp += 1;
    return myTmp;
}

//returning the position of the selected pod from the global pods array
//if it is not already in the tasks array and if it is not taken (a robot has taken it)
//else continuing searching until finding a pod to add as a task (this could be a potential problem...)
position selectAPod(int tmp) {
    int myTmp = tmp;
    bool in = true;
    position newPos = {-1, -1};
    while (in) {
        if (!thisPodPositionIsPresentInTasks(pods[myTmp])) {
            if (!pods[myTmp].taken) {
                newPos.row = pods[myTmp].pos.row;
                newPos.col = pods[myTmp].pos.col;
                in = false;
            }
        }
        myTmp = anotherTmp(myTmp);
    }
    return newPos;
}

int getNumOfTakenPods() {
    int num = 0;
    int i;
    for (i = 0; i &lt; NUM_OF_PODS; i++) {
        if (pods[i].taken) {
            num++;
        }
    }
    return num;
}

//selecting a position which corresponding to a free pod using the random value in input
//adding it as task in the tasks array, updating the true length of it
void addTask(int randomValue) {
    
    int numberOfTakenPods = getNumOfTakenPods();
     
    //every pods is tasked
    if ((actualLength + numberOfTakenPods) == NUM_OF_PODS) {
        allPodsUsed = true;
        return;
    }
    else
        allPodsUsed = false;
    
    
    //the array has reached the max length possible?
    if (actualLength &lt; MAX_TASK) {
        position taskPos = selectAPod(randomValue);
        tasks[actualLength] = taskPos;
        actualLength += 1;
        exploded = false;
    }
    else
        exploded = true;
}

//-----------------------------------------------------------------------------------------------

//extracting a position of a pod with a FIFO policy
position extractFIFO() {
    position tmp = tasks[0];
    int i = 1;
    while (i &lt; actualLength) {
        tasks[i-1] = tasks[i];
        i++;
    }
    tasks[i-1].row = -1;
    tasks[i-1].col = -1;
    actualLength--;
    return tmp;
}

void setPodAsTaken(position podPos) {
    int i;
    for(i = 0; i &lt; NUM_OF_PODS; i++) {
        if(pods[i].pos.row == podPos.row &amp;&amp; pods[i].pos.col == podPos.col) {
            pods[i].taken = true;
            return;
        }
    }
}

//estract a task from the queue and insert it in the robotTask array in the position represented by actualRobotId
void takeTask() {
    //if there is no task, TM will not set a position for the robot
    if (actualLength != 0) {
        position ext;
        ext = extractFIFO();
        robotTask[actualRobotId] = ext;
        setPodAsTaken(ext);
    }
    else {
        // if there are no task, we make sure that the robot cannot "re-do" the previous task
        robotTask[actualRobotId] = nullPosition;
    }
    actualRobotId = -1;
}</declaration>
		<location id="id15" x="-229" y="-119">
			<name x="-239" y="-153">Idle</name>
			<label kind="invariant" x="-246" y="-170">t &lt;= delay</label>
		</location>
		<location id="id16" x="25" y="-119">
			<name x="42" y="-127">Adding_task</name>
			<committed/>
		</location>
		<location id="id17" x="-229" y="93">
			<name x="-272" y="110">Releasing_task</name>
			<committed/>
		</location>
		<location id="id18" x="-391" y="-195">
			<name x="-401" y="-229">SettingUp</name>
			<committed/>
		</location>
		<init ref="id18"/>
		<transition>
			<source ref="id18"/>
			<target ref="id15"/>
			<label kind="assignment" x="-399" y="-153">t = 0,
settingUp(),
computeDelay()</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-374" y="-17">releaseTask!</label>
			<label kind="assignment" x="-357" y="0">takeTask()</label>
			<nail x="-280" y="-8"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-178" y="34">claim?</label>
			<label kind="assignment" x="-204" y="59">actualRobotId = synchronizationRequest</label>
			<nail x="-170" y="-8"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="select" x="-110" y="-42">tmp: int[0,NUM_OF_PODS-1]</label>
			<label kind="assignment" x="-110" y="-25">t = 0, addTask(tmp), computeDelay()</label>
			<nail x="-110" y="-42"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="guard" x="-136" y="-212">t &gt;= delay</label>
			<nail x="-110" y="-187"/>
		</transition>
	</template>
	<system>// Place template instantiations here.

h = Human(3, 1);
r0 = Robot(0, 2, 2);
r1 = Robot(1, 2, 2);
r2 = Robot(2, 2, 2);

taskManager = TaskManager(7, 3);

semaphore = Semaphore();

// List one or more processes to be composed into a system.
system r0, r1, r2, taskManager, h, semaphore;
    </system>
	<queries>
		<query>
			<formula>A[] not deadlock</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt;(g &lt; 100 &amp;&amp; deadlock)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt;(taskManager.exploded == true)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt;(taskManager.actualLength == 25)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=5](&lt;&gt;h.Taking_item)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=10000](&lt;&gt;taskManager.exploded == true)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=1000](&lt;&gt;taskManager.actualLength == 1)</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
