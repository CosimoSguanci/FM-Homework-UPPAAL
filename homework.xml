<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/************************************/
/*     Custom types declaration     */
/************************************/

typedef struct {
    int row;
    int col;
} position;

typedef struct {
    position pos;
    bool taken;
} pod;

/*************************************/
/*       Functions declaration       */
/*************************************/

position createPosition(int row, int col) {
    position pos;
    pos.row = row;
    pos.col = col;
    return pos;
}

/*************************************/
/*       Constants declaration       */
/*************************************/

const int N = 10;
const int M = 10;

const int NUM_OF_PODS = 30;

const int ROW_ENTRY_POINT = 0;
const int COL_ENTRY_POINT = 9;
const int ROW_DELIVERY_POINT = 9;
const int COL_DELIVERY_POINT = 9;
const int NUM_OF_ROBOTS = 3;

const int EMPTY = 0;
const int ROBOT = 1;
const int POD = 2;
const int POD_ROBOT = 3; // pod + robot in the same cell (the pods has just been released)

const int TO_DELIVERY = 0;
const int TO_POD = 1;
const int BACK_TO_POD = 2;


const position entryPoint = createPosition(ROW_ENTRY_POINT, COL_ENTRY_POINT);
const position deliveryPoint = createPosition(ROW_DELIVERY_POINT, COL_DELIVERY_POINT);


int grid[N][M] = {
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},
    {POD, POD, POD, POD, POD, POD, EMPTY, EMPTY, EMPTY, EMPTY},
    {EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY}
};

pod pods[NUM_OF_PODS] = {
    {{1, 0}, false}, {{1, 1}, false}, {{1, 2}, false}, {{1, 3}, false},
    {{1, 4}, false}, {{1, 5}, false}, {{3, 0}, false}, {{3, 1}, false},
    {{3, 2}, false}, {{3, 3}, false}, {{3, 4}, false}, {{3, 5}, false},
    {{5, 0}, false}, {{5, 1}, false}, {{5, 2}, false}, {{5, 3}, false},
    {{5, 4}, false}, {{5, 5}, false}, {{7, 0}, false}, {{7, 1}, false},
    {{7, 2}, false}, {{7, 3}, false}, {{7, 4}, false}, {{7, 5}, false},
    {{9, 0}, false}, {{9, 1}, false}, {{9, 2}, false}, {{9, 3}, false},
    {{9, 4}, false}, {{9, 5}, false}
};

const int MAX_T = 50;

position robotTask[NUM_OF_ROBOTS] = {
    createPosition(-1, -1),
    createPosition(-1, -1),
    createPosition(-1, -1)
}; // set by taskManager, read by the robots when the broadcast channel is activate
//every robot will read to his position and if the position is different from {-1,-1}
//the robot will be able to move to that pod

int synchronizationRequest; // used by TaskManager

int nextPositionRobotId; // used by Semaphore
int justMovedRobotId; // used by Semaphore

position nextPositionShared = {-1, -1};

/*position nextPositionsShared = {
    createPosition(-1, -1),
    createPosition(-1, -1),
    createPosition(-1, -1)    
};*/

/*************************************/
/*       Channels declaration        */
/*************************************/

chan go, takeItem, claim, canMove, cannotMove, noFeasibleMoves, tryingToMove, justMoved;
broadcast chan releaseTask;</declaration>
	<template>
		<name>Semaphore</name>
		<declaration>position nextPositions[NUM_OF_ROBOTS] = {
    {-1, -1},
    {-1, -1},
    {-1, -1}
};

void initializeNextPositions() {
    int i = 0;
    for(i = 0; i &lt; NUM_OF_ROBOTS; i++) {
        nextPositions[i].row = -1;
        nextPositions[i].col = -1;
    }
}

bool isAlreadyOccupiedForNextPositions(int row, int col) {
    int i = 0;
    for(i = 0; i &lt; NUM_OF_ROBOTS; i++) {
        if(nextPositions[i].row == row &amp;&amp; nextPositions[i].col == col) {
            return true;
        }
    }

    return false;
}

void setNextPosition(int row, int col, int robotId) {
    nextPositions[robotId].row = row;
    nextPositions[robotId].col = col;
}</declaration>
		<location id="id0" x="-68" y="-34">
			<committed/>
		</location>
		<location id="id1" x="102" y="68">
			<name x="0" y="59">initial_state</name>
		</location>
		<location id="id2" x="-17" y="195">
			<committed/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="153" y="25">justMoved?</label>
			<label kind="assignment" x="153" y="42">nextPositions[justMovedRobotId] = createPosition(-1, -1)</label>
			<nail x="119" y="25"/>
			<nail x="153" y="34"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="399" y="-297">noFeasibleMoves?</label>
			<nail x="467" y="-255"/>
			<nail x="926" y="17"/>
			<nail x="918" y="76"/>
			<nail x="119" y="76"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-136" y="144">canMove?</label>
			<nail x="-68" y="136"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="-51" y="-17">grid[nextPositionShared.row][nextPositionShared.col] != EMPTY || 
isAlreadyOccupiedForNextPositions(nextPositionShared.row, nextPositionShared.col)</label>
			<label kind="synchronisation" x="-51" y="17">cannotMove!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="161" y="102">grid[nextPositionShared.row][nextPositionShared.col] == EMPTY &amp;&amp; 
!isAlreadyOccupiedForNextPositions(nextPositionShared.row, nextPositionShared.col)</label>
			<label kind="synchronisation" x="161" y="136">canMove!</label>
			<label kind="assignment" x="161" y="152">setNextPosition(nextPositionShared.row, nextPositionShared.col, nextPositionRobotId)</label>
			<nail x="170" y="195"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="34" y="136">tryingToMove?</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>int H</parameter>
		<declaration>clock t;</declaration>
		<location id="id3" x="-229" y="-85">
			<name x="-272" y="-102">Idle</name>
		</location>
		<location id="id4" x="-42" y="-85">
			<name x="-52" y="-119">Taking_item</name>
			<label kind="invariant" x="-52" y="-68">t &lt;= H</label>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-153" y="-17">t &gt;= H</label>
			<label kind="synchronisation" x="-144" y="0">go!</label>
			<nail x="-136" y="-25"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-170" y="-187">takeItem?</label>
			<label kind="assignment" x="-153" y="-170">t = 0</label>
			<nail x="-136" y="-144"/>
		</transition>
	</template>
	<template>
		<name>Robot</name>
		<parameter>int id, int K</parameter>
		<declaration>clock t;

position currentPosition;
position currentPodPosition;
position nextPosition;

bool noPossibleMoves;

int target;

void updateGridAfterMove() {
    grid[currentPosition.row][currentPosition.col] = EMPTY;
    grid[nextPosition.row][nextPosition.col] = ROBOT;
    currentPosition = nextPosition;
}

bool isNormalMove() {
    return 
        (!(currentPosition == deliveryPoint &amp;&amp; target == TO_DELIVERY) &amp;&amp;
        !(target == TO_POD &amp;&amp; currentPosition == currentPodPosition) &amp;&amp;
        !(target == BACK_TO_POD &amp;&amp; currentPosition == currentPodPosition));
}

void releasePod() {
    int i;
    for(i = 0; i &lt; NUM_OF_PODS; i++) {
        if(pods[i].pos.row == currentPodPosition.row &amp;&amp; pods[i].pos.col == currentPodPosition.col) {
            pods[i].taken = false;
            grid[currentPodPosition.row][currentPodPosition.col] = POD_ROBOT;
            currentPodPosition = createPosition(-1, -1);
            return;
        }
    }
}

void takePod() {
    grid[currentPodPosition.row][currentPodPosition.col] = POD_ROBOT;
}
</declaration>
		<location id="id5" x="603" y="229">
			<name x="620" y="221">Moving</name>
			<label kind="invariant" x="620" y="238">t &lt;= K</label>
		</location>
		<location id="id6" x="476" y="450">
			<name x="442" y="476">DecideAction</name>
			<committed/>
		</location>
		<location id="id7" x="603" y="-68">
			<name x="593" y="-102">WaitingGreenLight</name>
			<committed/>
		</location>
		<location id="id8" x="297" y="-68">
			<name x="238" y="-110">DecideDirection</name>
			<committed/>
		</location>
		<location id="id9" x="297" y="178">
			<name x="314" y="170">PullUpPod</name>
			<committed/>
		</location>
		<location id="id10" x="0" y="170">
			<name x="-144" y="161">WaitingHuman</name>
		</location>
		<location id="id11" x="-85" y="0">
			<name x="-136" y="17">ClaimingTask</name>
		</location>
		<location id="id12" x="-399" y="0">
			<name x="-391" y="8">idle</name>
		</location>
		<location id="id13" x="8" y="-68">
		</location>
		<location id="id14" x="8" y="484">
			<name x="-2" y="450">PutDownPod</name>
			<committed/>
		</location>
		<location id="id15" x="357" y="-314">
			<name x="331" y="-348">WaitingForPossibleMoves</name>
			<label kind="invariant" x="382" y="-323">t &lt;= K</label>
		</location>
		<init ref="id12"/>
		<transition>
			<source ref="id15"/>
			<target ref="id8"/>
			<nail x="170" y="-314"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id15"/>
			<label kind="guard" x="348" y="-263">noPossibleMoves</label>
			<label kind="synchronisation" x="348" y="-246">noFeasibleMoves!</label>
			<label kind="assignment" x="348" y="-229">t = 0</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id12"/>
			<nail x="-399" y="484"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id14"/>
			<label kind="guard" x="76" y="493">target == BACK_TO_POD &amp;&amp;
currentPosition == currentPodPosition</label>
			<label kind="assignment" x="76" y="527">releasePod()</label>
			<nail x="425" y="484"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id8"/>
			<label kind="guard" x="8" y="-153">robotTask[id] != createPosition(-1, -1)</label>
			<label kind="assignment" x="9" y="-127">currentPodPosition = robotTask[id], 
target = TO_POD</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="guard" x="-348" y="-195">robotTask[id] == createPosition(-1, -1)</label>
			<nail x="-68" y="-170"/>
			<nail x="-399" y="-170"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="494" y="322">justMoved!</label>
			<label kind="assignment" x="494" y="339">updateGridAfterMove(),
justMovedRobotId = id</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="612" y="-17">canMove?</label>
			<label kind="assignment" x="612" y="0">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="374" y="-187">cannotMove?</label>
			<nail x="416" y="-162"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="365" y="-51">!noPossibleMoves</label>
			<label kind="synchronisation" x="382" y="-34">tryingToMove!</label>
			<label kind="assignment" x="331" y="-102">nextPosition = createPosition(1, 1),
nextPositionRobotId = id,
nextPositionShared = nextPosition</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="425" y="102">isNormalMove()</label>
			<nail x="501" y="51"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="guard" x="170" y="246">target == TO_POD &amp;&amp;
currentPosition == currentPodPosition</label>
			<label kind="assignment" x="246" y="289">takePod()</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="assignment" x="221" y="93">target = TO_DELIVERY</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id10"/>
			<label kind="guard" x="-255" y="246">currentPosition == deliveryPoint &amp;&amp; 
target == TO_DELIVERY</label>
			<label kind="synchronisation" x="-178" y="289">takeItem!</label>
			<nail x="0" y="340"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="136" y="8">go?</label>
			<label kind="assignment" x="76" y="34">target = BACK_TO_POD</label>
			<nail x="8" y="68"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="17" y="-34">releaseTask?</label>
			<nail x="8" y="0"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-255" y="-60">claim!</label>
			<label kind="assignment" x="-314" y="-34">synchronizationRequest = id</label>
		</transition>
	</template>
	<template>
		<name>TaskManager</name>
		<parameter>int T</parameter>
		<declaration>clock t;

//this is a queue which works with a FIFO policy, where MAX_T is the maximum number of tasks settable
position tasks[MAX_T];
//to keep track of the actual number of task present in the tasks array
int actualLength;
//here there is the id of the robot which has claimed a task
int actualRobotId;
//used to signal if the max capacity of the array is reached
bool exploded;
//used to signal if all pods in the grid is tasked
bool allPodsUsed;

//to initialize every local variable
void settingUp() {
    int j;
    for (j = 0; j &lt; MAX_T; j++) {
        tasks[j] = createPosition(-1,-1);
    }
    actualLength = 0;
    actualRobotId = -1;
    exploded = false;
    allPodsUsed = false;
}

//This checks the position of the pod to understand if it is the same of the pod in position i inside the tasks queue
bool checkIdentity(pod myPod, int i) {
    if (myPod.pos.row == tasks[i].row) {
        if (myPod.pos.col == tasks[i].col) {
            return true;
        }
    }
    return false;
}

//This verify if the pod in input is present in the queue checking all the tasks array (if it is the case)
bool thisPodPositionIsPresentInTasks(pod myPod) {
    int i;
    for (i = 0; i &lt; actualLength; i++) {
        if (checkIdentity(myPod, i)) {
            return true;
        }
    }
    return false;
}

//find another "random" number adding 1 to the previous random number, keeping attention to the NUM_OF_PODS present in the layout
int anotherTmp(int tmp) {
    int myTmp = tmp;
    if (tmp == NUM_OF_PODS - 1)
        myTmp = 0;
    else
        myTmp += 1;
    return myTmp;
}

//returning the position of the selected pod from the global pods array
//if it is not already in the tasks array and if it is not taken (a robot has taken it)
//else continuing searching until finding a pod to add as a task (this could be a potential problem...)
position selectAPod(int tmp) {
    int myTmp = tmp;
    bool in = true;
    position newPos = {-1, -1};
    while (in) {
        if (!thisPodPositionIsPresentInTasks(pods[myTmp])) {
            if (!pods[myTmp].taken) {
                newPos.row = pods[myTmp].pos.row;
                newPos.col = pods[myTmp].pos.col;
                in = false;
            }
        }
        myTmp = anotherTmp(myTmp);
    }
    return newPos;
}

//selecting a position which corresponding to a free pod using the random value in input
//adding it as task in the tasks array, updating the true length of it
void addTask(int randomValue) {
    //every pods is tasked
    if (actualLength == NUM_OF_PODS) {
        allPodsUsed = true;
        return;
    }
    else
        allPodsUsed = false;
    //the array has reached the max length possible?
    if (actualLength &lt; MAX_T) {
        position taskPos = selectAPod(randomValue);
        tasks[actualLength] = taskPos;
        actualLength += 1;
        exploded = false;
    }
    else
        exploded = true;
}

//-----------------------------------------------------------------------------------------------

//extracting a position of a pod with a FIFO policy
position extractFIFO() {
    position tmp = tasks[0];
    int i = 1;
    while (i &lt; actualLength) {
        tasks[i-1] = tasks[i];
        i++;
    }
    tasks[i-1].row = -1;
    tasks[i-1].col = -1;
    actualLength--;
    return tmp;
}

void setPodAsTaken(position podPos) {
    int i;
    for(i = 0; i &lt; NUM_OF_PODS; i++) {
        if(pods[i].pos.row == podPos.row &amp;&amp; pods[i].pos.col == podPos.col) {
            pods[i].taken = true;
            return;
        }
    }
}

//estract a task from the queue and insert it in the robotTask array in the position represented by actualRobotId
void takeTask() {
    //if there is no task, TM will not set a position for the robot
    if (actualLength != 0) {
        position ext;
        ext = extractFIFO();
        robotTask[actualRobotId] = ext;
        setPodAsTaken(ext);
    }
    else {
        int i;
        for(i = 0; i &lt; NUM_OF_ROBOTS; i++) {
            robotTask[i] = createPosition(-1, -1);
        } 
    }
    actualRobotId = -1;
}</declaration>
		<location id="id16" x="-229" y="-119">
			<name x="-239" y="-153">Idle</name>
			<label kind="invariant" x="-246" y="-170">t &lt;= T</label>
		</location>
		<location id="id17" x="25" y="-119">
			<name x="42" y="-127">Adding_task</name>
			<committed/>
		</location>
		<location id="id18" x="-229" y="93">
			<name x="-272" y="110">Releasing_task</name>
			<committed/>
		</location>
		<location id="id19" x="-391" y="-195">
			<name x="-401" y="-229">SettingUp</name>
			<committed/>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id19"/>
			<target ref="id16"/>
			<label kind="assignment" x="-373" y="-157">settingUp()</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-374" y="-17">releaseTask!</label>
			<label kind="assignment" x="-357" y="8">takeTask()</label>
			<nail x="-280" y="-8"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-178" y="34">claim?</label>
			<label kind="assignment" x="-204" y="59">actualRobotId = synchronizationRequest</label>
			<nail x="-170" y="-8"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="select" x="-110" y="-51">tmp: int[0,NUM_OF_PODS-1]</label>
			<label kind="assignment" x="-93" y="-25">t = 0, addTask(tmp)</label>
			<nail x="-110" y="-42"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id17"/>
			<nail x="-110" y="-187"/>
		</transition>
	</template>
	<system>// Place template instantiations here.

h = Human(10);
r0 = Robot(0, 2);
r1 = Robot(1, 2);
r2 = Robot(2, 2);

taskManager = TaskManager(15);

semaphore = Semaphore();

// List one or more processes to be composed into a system.
system h, r0, r1, r2, taskManager, semaphore;
    </system>
	<queries>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
	</queries>
</nta>
